package cz.radekm.msTeams

import com.microsoft.graph.models.extensions.ChatMessage
import com.microsoft.graph.models.generated.{BodyType, ChatMessageType}
import cz.radekm.msTeams.Teams.Message
import cz.radekm.msTeams.Teams.Message.{Mention, Reaction}
import monix.eval.Task

import java.time.Instant
import scala.jdk.CollectionConverters._

object Teams {
  case class User(id: String @@ "User", name: String)

  case class Team(id: String @@ "Team", name: String)
  // More permissions are needed to list channel members. So we omit that.
  case class Channel(team: Team, id: String @@ "Channel", name: String)

  // Chat members can be listed.
  case class Chat(id: String @@ "Chat", members: List[User])

  case class Message(
    id: String @@ "Message",
    // None when message was generated by a bot.
    author: Option[User],
    created: Instant,
    subject: Option[String],
    body: Message.Content,
    reactions: Set[Reaction],
    mentions: Set[Mention],
  )
  object Message {
    case class Reaction(reactionType: String, userId: String @@ "User", created: Instant)

    sealed abstract class Mention
    final case class UserMention(user: User) extends Mention
    final case class OtherMention(desc: String) extends Mention

    sealed abstract class Content
    final case class Text(data: String) extends Content
    final case class Html(data: String) extends Content
  }
}

object TeamsClient {
  val ScopesForTeams = Set("User.Read", "Chat.Read", "Team.ReadBasic.All", "Channel.ReadBasic.All")

  def obtainUserAccessTokenThroughTerminal(appId: AppId, scopes: Set[String]) : Task[Token] =
    Task.async { cb =>
      MsGraphClient.obtainUserAccessTokenViaTerminal(appId, scopes)
        .thenAccept(result => cb(Right(result.accessToken().tagWith["Token"])))
        .exceptionally { e => cb(Left(e)); null }
    }

  def make(appId: AppId): Task[TeamsClient] =
    for {
      token <- obtainUserAccessTokenThroughTerminal(appId, ScopesForTeams)
    } yield new TeamsClient(token)
}

class TeamsClient(accessToken: Token) {
  private val graph = new MsGraphClient(accessToken)

  def user: Task[Teams.User] = Task {
    val u = graph.user
    Teams.User(id = u.id.tagWith["User"], name = u.displayName)
  }

  def channels: Task[List[Teams.Channel]] = Task {
    graph.teams.flatMap { t =>
      val team = Teams.Team(id = t.id.tagWith["Team"], name = t.displayName)
      graph.channels(team.id).map { ch =>
        Teams.Channel(team = team, id = ch.id.tagWith["Channel"], name = ch.displayName)
      }
    }
  }

  def chats: Task[List[Teams.Chat]] = Task {
    graph.chats.map { ch =>
      val members = graph.chatMembers(ch.id).map { m => Teams.User(id = m.id.tagWith["User"], name = m.displayName) }
      Teams.Chat(id = ch.id.tagWith["Chat"], members = members)
    }
  }

  private def convertChatMessage(m: ChatMessage): Option[Teams.Message] = if (m.body.content != null && m.from != null) {
    if (m.messageType != ChatMessageType.MESSAGE)
      sys.error(s"Unexpected message type ${m.messageType}")
    val message = Teams.Message(
      id = m.id.tagWith["Message"],
      author = Option(m.from.user).map { u => Teams.User(id = u.id.tagWith["User"], name = u.displayName) },
      created = m.createdDateTime.toInstant,
      subject = Option(m.subject).filterNot(_.isBlank),
      body = m.body.contentType match {
        case BodyType.HTML => Teams.Message.Html(m.body.content)
        case BodyType.TEXT => Teams.Message.Text(m.body.content)
        case BodyType.UNEXPECTED_VALUE => sys.error("Cannot convert content")
      },
      reactions = m.reactions.asScala.map { r => Teams.Message.Reaction(
        reactionType = r.reactionType,
        userId = r.user.user.id.tagWith["User"],
        created = r.createdDateTime.toInstant
      ) }.toSet,
      mentions = m.mentions.asScala.map { m => m.mentioned.user match {
        case null => Teams.Message.OtherMention(m.mentionText)
        case u => Teams.Message.UserMention(Teams.User(id = u.id.tagWith["User"], name = u.displayName))
      } }.toSet,
    )
    Some(message)
  } else None

  def messages(channel: Teams.Channel): Task[List[Message]] = Task {
    graph.channelMessages(channel.team.id, channel.id).flatMap(convertChatMessage)
  }

  def messages(chat: Teams.Chat): Task[List[Message]] = Task {
    graph.chatMessages(chat.id).flatMap(convertChatMessage)
  }

  def repliesToMessage(channel: Teams.Channel, message: Message): Task[List[Message]] = Task {
    graph.channelMessageReplies(channel.team.id, channel.id, message.id).flatMap { r =>
      val reply = convertChatMessage(r)
      if (r.replyToId == null) None
      else if (r.replyToId != message.id)
        sys.error(s"Got reply $reply in channel which is not reply to $message")
      else reply
    }
  }
}
